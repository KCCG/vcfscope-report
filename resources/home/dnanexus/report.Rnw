%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  
%  KCCG WGS Performance Reporter -- Report generator
%  
%  Usage: 
%    Rscript --vanilla -e "library(knitr); knit('report.Rnw', output = 'report.tex')"
%  
%
%  Mark Pinese, 2015
%  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[10pt,a4paper]{article}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{url}

\usepackage{fancyhdr}
\setlength{\headheight}{15.2pt}
\pagestyle{fancyplain}
\usepackage{lastpage}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PREPARATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% LIBRARIES AND HELPER FUNCTIONS
%--------------------------------------------------------------------
<<load-libs, cache=FALSE, echo=FALSE>>=
suppressMessages(library(GenomicRanges))
suppressMessages(library(ggplot2))
suppressMessages(library(plyr))
suppressMessages(library(xtable))

suppressMessages(source("report_functions.R"))
@


% ERROR BAR GLOBAL SETTINGS
%--------------------------------------------------------------------
<<settings, cache=FALSE, echo=FALSE>>=
CI_MODEL = "betabin"
CI_LEVEL = 0.95
@


% LOAD PRECOMPUTED RESULTS
%--------------------------------------------------------------------
<<load-results, cache=FALSE, echo=FALSE>>=
env = Sys.getenv(names = TRUE)
rds_list_path = env["PARAM_INPUT_RDS_PATH"]
rds_list = scan(rds_list_path, character())

data = list()
for (path in rds_list)
{
    data[[path]] = readRDS(path)

    # Ensure that all the input files were generated using the same
    # settings.
    stopifnot(data[[path]]$params$criterion == data[[1]]$params$criterion)
    stopifnot(data[[path]]$params$criterion_latex == data[[1]]$params$criterion_latex)
    stopifnot(data[[path]]$params$region.subset == data[[1]]$params$region.subset)
    stopifnot(data[[path]]$params$region.subset.path == data[[1]]$params$region.subset.path)
    stopifnot(data[[path]]$params$path.gold.variants.orig == data[[1]]$params$path.gold.variants.orig)
    stopifnot(data[[path]]$params$path.gold.regions.orig == data[[1]]$params$path.gold.regions.orig)
    stopifnot(data[[path]]$params$genome == data[[1]]$params$genome)
    stopifnot(data[[path]]$params$path.genome == data[[1]]$params$path.genome)
    for (i in names(data[[1]]$params$version))
        stopifnot(data[[path]]$params$version[[i]] == data[[1]]$params$version[[i]])
}

data.labels = abbreviate(gsub(".*/", "", names(data)))
names(data.labels) = names(data)
for (i in seq_along(data))
    data[[i]]$label = data.labels[[i]]

universe = data[[1]]$universe
shared_params = data[[1]]$params[c("criterion", "criterion_latex", "region.subset", "region.subset.path", "path.gold.variants.orig", "path.gold.regions.orig", "genome", "path.genome", "version")]
shared_hashes = data[[1]]$hashes[c("region.subset.path", "path.gold.variants.orig", "path.gold.regions.orig", "path.genome")]
@


% KNITR SETUP
%--------------------------------------------------------------------
<<setup, cache=FALSE, echo=FALSE>>=
library(knitr)
options(
	tikzDocumentDeclaration = "\\documentclass[11pt]{article}",
	tikzLatexPackages = c(
		getOption("tikzLatexPackages"),
		"\\usepackage{amsmath}"),
	tikzMetricsDictionary="tikzMetrics"
)
opts_chunk$set(
	echo = FALSE, results = 'markup', message = FALSE, warning = FALSE, error = TRUE, 
	fig.align = 'center', cache = FALSE, cache.lazy = FALSE)
opts_knit$set(progress = TRUE, verbose = TRUE)
options(warn = 1)
@


% SUPPLIED REGION BED DETAILS
% --------------------------------------------------------------------
<<region-details, echo=FALSE, cache=FALSE>>=
temp.region_md5 = "NA"
temp.region_label = "NO"
if (shared_params$region.subset)
{
    temp.region_label = "YES"
    temp.region_md5 = data[[1]]$hashes$region.subset.path
}
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% REPORT STARTS HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\fancyhf{}
\lhead{WGS Performance Report (v\texttt{\Sexpr{shared_params$version$script}})}
\rhead{Page \thepage\ of \pageref{LastPage}}

\let\endtitlepage\relax
\begin{titlepage}
\begin{flushleft}
\LARGE{WGS Performance Report}
\HRule
\end{flushleft}
\end{titlepage}


\section{Summary}
Number of samples: \texttt{\Sexpr{length(data)}} \\
Analysis restricted to regions? \Sexpr{temp.region_label} \\
Report version: \texttt{\Sexpr{shared_params$version$script}} \\
Report time: \texttt{\Sexpr{date()}} \\
Call criterion: \Sexpr{shared_params$criterion_latex} \\


\section{Samples}
<<sample-table,results='asis'>>=
temp.sample_table = xtable(data.frame(
    "Label" = sapply(data, function(x) texquote(x$label)),
    "Name" = sapply(data, function(x) texquote(x$params$sample.id)),
    "VCF" = paste("\\texttt{", sapply(data, function(x) texquote(gsub(".*/", "", x$params$path.test.orig))), "}"),
    "MD5" = paste("\\texttt{", sapply(data, function(x) gsub("\\s+$", "", x$hashes$path.test.orig)), "}")),
    align = "lllll")
print(temp.sample_table, sanitize.text.function = function(x) x, include.rownames = FALSE)
@


\section{Region analysed}
<<subset-calcs>>=
temp.size_genome = sum(as.numeric(width(universe$genome)))      # | GENOME |
temp.size_subset = sum(as.numeric(width(universe$subset)))      # | BED ^ GENOME |
temp.size_gold = sum(as.numeric(width(universe$analysis)))      # | GIAB ^ BED ^ GENOME |
@


\begin{itemize}
Of the \Sexpr{formatC2(temp.size_genome, digits=0, format="f", big.mark=",")} bases in the genome, \Sexpr{formatC2(temp.size_subset, digits=0, format="f", big.mark=",")} (\Sexpr{round(temp.size_subset / temp.size_genome * 100, 2)}\%) were in the supplied report target regions.  Of the target bases, \Sexpr{formatC2(temp.size_gold, digits=0, format="f", big.mark=",")} (\Sexpr{round(temp.size_gold / temp.size_subset * 100, 2)}\%) had gold-standard genotype available, and were used in this report.
\end{itemize}

<<subset-plots,fig.height=4,fig.width=6.4,out.width='4in'>>=
plotGenomeBreakdown(f_targ_of_wg = temp.size_subset / temp.size_genome, f_gold_of_targ = temp.size_gold / temp.size_subset)
@


\section{Performance}
\subsection{Sensitivity}
<<sensitivity-plots,fig.width=5,fig.height=5,out.width='2.5in',fig.show='hold'>>=
ggplot(calcPerformanceStats(data, quote(muttype == "Subst" & zyg %in% c("RA", "AA")), .(zyg), model = CI_MODEL, conf_level = CI_LEVEL), aes(x = zyg, y = sens.est, fill = zyg)) + 
    geom_bar(stat = "identity", position = "dodge") + 
    geom_errorbar(aes(ymin = sens.lcl, ymax = sens.ucl), width = 0.2) + 
    labs(x = "", y = "Sensitivity", fill = "Zygosity", title = "SNV Detection") + 
    theme_bw() + ylim(0, 1)

ggplot(marginalizePerformance(data[[1]]$class_subsets.performance_thresholded, quote(muttype == "Subst" & zyg %in% c("RA", "AA")), .(zyg)), aes(x = zyg, y = n, fill = zyg)) + 
    geom_bar(stat = "identity", position = "dodge") + 
    labs(x = "", y = "Number of mutations", fill = "Zygosity", title = "SNV Counts in Gold Standard") + 
    theme_bw()


ggplot(calcPerformanceStats(data, quote(muttype == "Subst" & zyg %in% c("RA", "AA")), .(zyg, depth), model = CI_MODEL, conf_level = CI_LEVEL), aes(x = depth, y = sens.est, group = zyg, colour = zyg)) + 
    geom_line() + 
    geom_ribbon(aes(ymin = sens.lcl, ymax = sens.ucl, fill = zyg), alpha = 0.25, colour = NA) + 
    geom_point(size = 2, shape = 21, fill = "white") + 
    labs(x = "Sequence depth (inclusive)", y = "Sensitivity", fill = "Zygosity", colour = "Zygosity", title = "SNV Detection vs Depth") + 
    theme_bw() + ylim(0, 1)

ggplot(
    marginalizePerformance(data[[1]]$class_subsets.performance_thresholded, quote(muttype == "Subst" & zyg %in% c("RA", "AA")), .(zyg, depth)), 
    aes(x = depth, y = ntp + nfn, group = zyg, colour = zyg)) + 
    geom_line() + 
    geom_point(size = 2, shape = 21, fill = "white") + 
    labs(x = "Sequence depth (inclusive)", y = "Number of mutations", fill = "Zygosity", colour = "Zygosity", title = "SNV Counts in Gold Standard") + 
    theme_bw()


ggplot(calcPerformanceStats(data, quote(muttype == "Ins" & zyg %in% c("RA", "AA")), .(zyg, mutsize), model = CI_MODEL, conf_level = CI_LEVEL), aes(x = mutsize, y = sens.est, group = zyg, colour = zyg)) + 
    geom_line() + 
    geom_ribbon(aes(ymin = sens.lcl, ymax = sens.ucl, fill = zyg), alpha = 0.25, colour = NA) + 
    geom_point(size = 2, shape = 21, fill = "white") + 
    labs(x = "Number of bases inserted (inclusive)", y = "Sensitivity", fill = "Zygosity", colour = "Zygosity", title = "Insertion Detection Performance") + 
    theme_bw() + ylim(0, 1)

ggplot(
    marginalizePerformance(data[[1]]$class_subsets.performance_thresholded, quote(muttype == "Ins" & zyg %in% c("RA", "AA")), .(zyg, mutsize)), 
    aes(x = mutsize, y = ntp + nfn, group = zyg, colour = zyg)) + 
    geom_line() + 
    geom_point(size = 2, shape = 21, fill = "white") + 
    labs(x = "Number of bases inserted (inclusive)", y = "Number of mutations", fill = "Zygosity", colour = "Zygosity", title = "Insertion Counts in Gold Standard") + 
    theme_bw()


ggplot(calcPerformanceStats(data, quote(muttype == "Del" & zyg %in% c("RA", "AA")), .(zyg, mutsize), model = CI_MODEL, conf_level = CI_LEVEL), aes(x = mutsize, y = sens.est, group = zyg, colour = zyg)) + 
    geom_line() + 
    geom_ribbon(aes(ymin = sens.lcl, ymax = sens.ucl, fill = zyg), alpha = 0.25, colour = NA) + 
    geom_point(size = 2, shape = 21, fill = "white") + 
    labs(x = "Number of bases deleted (inclusive)", y = "Sensitivity", fill = "Zygosity", colour = "Zygosity", title = "Deletion Detection Performance") + 
    theme_bw() + ylim(0, 1)

ggplot(marginalizePerformance(data[[1]]$class_subsets.performance_thresholded, quote(muttype == "Del" & zyg %in% c("RA", "AA")), .(zyg, mutsize)), aes(x = mutsize, y = ntp + nfn, group = zyg, colour = zyg)) + 
    geom_line() + 
    geom_point(size = 2, shape = 21, fill = "white") + 
    labs(x = "Number of bases deleted (inclusive)", y = "Number of mutations", fill = "Zygosity", colour = "Zygosity", title = "Deletion Counts in Gold Standard") + 
    theme_bw()
@


\subsection{False Positive Rate}
<<false-positive-plots,fig.width=5,fig.height=5,out.width='2.5in',fig.show='hold'>>=
# FPR here is defined as number of FP calls per megabase of sequence within
# the subset under consideration.  Unfortunately, this denominator (the
# megabases of sequence in the subset) is not exactly known, as it cannot
# be calculated from the VCF, instead requiring very slow subset counting
# over the BAM depth data.  

# For now, get around this limitation by approximating the denominator.  
# Do this by assuming that variants are evenly spread throughout the 
# genome, irrespective of the value of subsetting covariates.  Then, the 
# fraction of variants in a subset (relative to all variants) is 
# proportional to the number of bases in the subset (relative to the 
# number of bases in all subsets).

# This is only an approximation for determining the FPR *within a subset*.
# For the total FPR over the whole genome (all subsets combined), which
# is the sum of all per-subset FPRs weighted by the relative subset
# sizes, the approximated term falls out and the result is exact.

# For example, in a given subset i,
#   NFPi/Ni = VFPRi  # False positive rate (relative to vars)
#   NFPi/Si = BFPRi  # False positive rate (relative to bases)
# VFPRi (the rate of false positives in all variants) is what we can 
# calculate, but we want BFPRi (the rate of false positives in all bases).
# We don't know Si, but approximate it by:
#   Si ~= Ni / N * S
# Where Ni is the number of variants in the subset, N is the total count
# of variants in all subsets, and S is the total number of bases in all
# subsets.  Then,
#   BFPRi ~= (NFPi/Ni) * (N/S)
# To determine the portion of the total false positive rate contributed
# by region i, BFPRi is weighted by Si/S:
#   TFPRi = BFPRi * Si/S
# And the total FPR is the sum of these TFPRis:
#   TFPR = sum(TFPRi)
# Substituting the approximation above:
#   TFPRi = (NFPi/Ni) * (N/S) * Ni / N * S / S
#         = NFPi/S
# Which contains no approximated terms -- the result is exact, and
# makes intuitive sense.

# We put the above in the framework of confidence interval estimation
# by calculating CIs on the NFPi/Ni ratio.  The scaling factors are
# not based on random variables, so don't affect the CI beyond linear
# scaling.

# Calculate VFPRi (this is fpr.vs_depth$fpr.est)
fpr.vs_depth = calcPerformanceStats(data, quote(TRUE), .(depth), model = CI_MODEL, conf_level = CI_LEVEL)

# Calculate:
#   S     total analysis bases
#   NFPi  number of false positive variants in each depth class, grouped by sample
#   Ni    number of true variants in each depth class, grouped by sample
#   N     number of true variants overall (should be the same in all samples)
fpr.S = sum(as.numeric(width(universe$analysis)))

fpr.NFPi = sapply(data, function(x) dlply(x$class_subsets.performance_thresholded, .(depth), function(y) sum(y$nfp)))
names(dimnames(fpr.NFPi)) = c("depth", "sample")
fpr.NFPi = matrix(unlist(fpr.NFPi), ncol = length(data), dimnames = dimnames(fpr.NFPi))
colnames(fpr.NFPi) = data.labels[colnames(fpr.NFPi)]

fpr.Ni = sapply(data, function(x) dlply(x$class_subsets.performance_thresholded, .(depth), function(y) sum(y$ntp + y$nfn)))
names(dimnames(fpr.Ni)) = c("depth", "sample")
fpr.Ni = matrix(unlist(fpr.Ni), ncol = length(data), dimnames = dimnames(fpr.Ni))
colnames(fpr.Ni) = data.labels[colnames(fpr.Ni)]

fpr.N = colSums(fpr.Ni)
stopifnot(length(unique(fpr.N)) == 1)
fpr.N = fpr.N[[1]]

# Use VFPRi estimates and bounds, and the scaling factors above, to
# estimate BFPRi and bounds.
# The 1e6 factor is to express the FPR in false positives per megabase
fpr.vs_depth$bfpr.est = fpr.vs_depth$fpr.est * fpr.N/fpr.S * 1e6
fpr.vs_depth$bfpr.lcl = fpr.vs_depth$fpr.lcl * fpr.N/fpr.S * 1e6
fpr.vs_depth$bfpr.ucl = fpr.vs_depth$fpr.ucl * fpr.N/fpr.S * 1e6


# Plot BFPRi ~ depth.  This is averaged over the replicate samples.
ggplot(fpr.vs_depth, aes(x = depth, y = bfpr.est, ymin = bfpr.lcl, ymax = bfpr.ucl)) + 
    geom_bar(stat = "identity") + 
    geom_errorbar() + 
    labs(x = "Sequence depth (inclusive)", y = "False positives per Mb (approx.)", title = "False Positive Rate: Effect of Depth") + 
    theme_bw()


# Now create an accessory plot showing the number of variants in each
# depth class.  This varies per sample, so work from the fpr.Ni structure.
library(reshape2)
fpr.Ni2 = melt(fpr.Ni, value.name = "count")

ggplot(fpr.Ni2, aes(x = depth, y = count, group = sample, colour = sample)) + 
    geom_line() + geom_point(size = 2, shape = 21, fill = "white") + 
    labs(x = "Sequence depth (inclusive)", y = "Variant positions with this depth", title = "Variant Count vs Depth", colour = "Sample Label") + 
    theme_bw()


# Finally create a plot which is effectively the combination of the
# previous two.  This is, for each sample, the number of false positive
# variants in each depth class.
fpr.NFPi2 = melt(fpr.NFPi, value.name = "count")

ggplot(fpr.NFPi2, aes(x = depth, y = count, group = sample, colour = sample)) + 
    geom_line() + geom_point(size = 2, shape = 21, fill = "white") + 
    labs(x = "Sequence depth (inclusive)", y = "False positives with this depth", title = "False Positive Count: Effect of Depth") + 
    theme_bw()
@



% DATA AND SOFTWARE VERSIONS
%--------------------------------------------------------------------
\section{Versions}
\begin{itemize}
\item Software: \begin{itemize}
	\item Performance script: \texttt{\Sexpr{texquote(shared_params$version$script)}}
	\item R: \texttt{\Sexpr{texquote(R.version$version.string)}} (\texttt{\Sexpr{texquote(R.version$platform)}})
	\item Genome: \texttt{\Sexpr{texquote(shared_params$genome)}} (\texttt{\Sexpr{packageVersion(shared_params$genome)}})
	\item Java: \texttt{\Sexpr{texquote(shared_params$version$java)}}
	\item RTG core: \texttt{\Sexpr{texquote(shared_params$version$rtg)}}
	\item Bedtools: \texttt{\Sexpr{texquote(shared_params$version$bedtools)}}
	\item Execution time: \Sexpr{date()}
\end{itemize}
\item Data: \begin{itemize}
	\item GiaB VCF: \texttt{\url{\Sexpr{shared_params$path.gold.variants.orig}}} (MD5 \texttt{\Sexpr{texquote(shared_hashes$path.gold.variants.orig)}})
	\item GiaB BED: \texttt{\url{\Sexpr{shared_params$path.gold.regions.orig}}} (MD5 \texttt{\Sexpr{texquote(shared_hashes$path.gold.regions.orig)}})
	\item Analysis restricted to regions? \Sexpr{temp.region_label} \begin{itemize}
		\item Analysis region BED: \texttt{\url{\Sexpr{shared_params$region.subset.path}}} (MD5 \texttt{\Sexpr{texquote(temp.region_md5)}})
	\end{itemize}
\item Statistics: \begin{itemize}
    \item Error bar method: \texttt{\Sexpr{texquote(CI_MODEL)}}
    \item Error bar level: \texttt{\Sexpr{CI_LEVEL}}
    \end{itemize}
\end{itemize}

\end{document}
